1.Дайте характеристику объекту в ООП. Приведите примеры классов в С#.
Объект в программе — это абстракция реального объекта. Объект обладает атрибутами, поведением и индивидуальностью. Атрибуты определяют основные черты объекта, поведение — действия над объектом, индивидуальность — отличие одного объекта от другого с такими же атрибутами по их конкретным значениям. Объект является экземпляром класса.
Класс – это множество объектов с одинаковыми атрибутами и поведением, представляемое в языке программирования в виде абстрактного типа данных, который включает в себя члены класса. Рассмотрим некоторые из них:
•	Поля – непосредственно данные определенного типа для описания атрибутов;
•	Методы - функции, предназначенные для обработки внутренних данных объекта данного класса;
•	Свойства – это специальные поля данных, с помощью которых, можно управлять поведением объектов данного класса.
Класс служит образцом для создания объектов или, другими словами, объект является экземпляром класса.
Примеры классов в С#:
class MyClass
{
    public int field;  //Поле
    public void Method() //Метод
    {
        Console.Writeline(field);
    }
}

class Persone
{
    public string name;
    public int age;
    public void PrintInfo()
    {
        Console.Writeline($”Имя: {name} Возраст: {age}”);
    }
}

2. Дайте характеристику платформе Microsoft .Net Framework С#.
Совокупность средств, с помощью которых программы пишутся, корректируются, преобразуются в машинные коды, отлаживаются и запускаются, называют средой разработки или оболочкой. Платформа .Net или .Net Framework – это среда разработки программ, объединение ранее разрозненных технологий компанией Microsoft, которые позволяют разрабатывать разнотипные приложения на различных языках программирования под различные операционные системы.
.NET Framework является надстройкой над операционной системой, в качестве которой может выступать любая ОС, и состоит из ряда компонентов. Так, .NET Framework включает в себя:
1.	Официальные языки: С#, VB.NET, Managed C++, JScript .NET и др.
2.	Общеязыковую объектно-ориентированную среду выполнения CLR (Common Language Runtime), совместно используемую этими языками для создания приложений.
3.	Ряд связанных между собой библиотек классов под общим именем FCL (Framework Class Library).

3. Перечислите функции основного компонента платформы .NET Framework
Основным компонентом платформы .NET Framework является общеязыковая среда выполнения программ CLR - это исполняющая среда, которая подходит для различных языков программирования. К функциям CLR относятся:
1.	двухшаговая компиляция: преобразование программы, написанной на одном из языков программирования в управляемый код на промежуточном языке (Microsoft Intermediate Language, MSIL, или просто IL), а затем преобразование IL-кода в машинный код конкретного процессора, который выполняется с помощью виртуальной машины или JIT-компилятора (Just In Time compiler - компилирование точно к нужному моменту);
2.	управление кодом: загрузка и выполнение уже готового IL-кода с помощью JIT-компилятора;
3.	осуществление доступа к метаданным с целью проверки безопасности кода;
4.	управление памятью при размещении объектов с помощью сборщика мусора (Garbage Collector);
5.	обработка исключений и исключительных ситуаций, включая межъязыковые исключения;
6.	осуществление взаимодействия между управляемым кодом (код, созданный для СLR) и неуправляемым кодом;
7.	поддержка сервисов для разработки разнотипных приложений.

4. Охарактеризуйте компонент .Net Framework FCL – библиотека классов платформы.
Компонент FCL – библиотека классов платформы. Эта библиотека разбита на несколько модулей таким образом, что имеется возможность использовать ту или иную ее часть в зависимости от требуемых результатов. 
Часть FCL посвящена описанию базисных типов. Тип — это способ представления данных; определение наиболее фундаментальных из них облегчает совместное использование языков программирования с помощью .NET Framework. Все вместе это называется Common Type System (CTS — единая система типов).
Кроме того, библиотека FCL включает в себя Common Language Specification (CLS – общая языковая спецификация), которая устанавливает: основные правила языковой интеграции. Спецификация CLS определяет минимальные требования, предъявляемые к языку платформы .NET. Компиляторы, удовлетворяющие этой спецификации, создают объекты, способные взаимодействовать друг с другом. Поэтому любой язык, соответствующий требованиям CLS, может использовать все возможности библиотеки FCL.

5. Какие типы приложений можно создавать в С#. Перечислите и дайте характеристику каждому типу.
Типы приложений:
1.	Консольные приложения позволяют выполнять вывод на "консоль", то есть в окно командного процессора.
2.	Windows-приложения, использующие элементы интерфейса Windows, включая формы, кнопки, флажки и т.д.
3.	Web-приложения представляют собой web-страницы, которые могут просматриваться любым web-браузером.
4.	Web-сервисы представляют собой распределенные приложения, которые позволяют обмениваться по Интернету практически любыми данными с использованием единого синтаксиса независимо от того, какой язык программирования применялся при создании web-службы и на какой системе она размещена.
Приложение, находящееся в процессе разработки, называется проектом. Несколько приложений могут быть объединены в решение (solution).

6. Методы: основные понятия. Перегрузка методов.
Методы – конструкция, наделяющая объекты функциональностью и позволяющая объектам взаимодействовать между собой и с другими частями программы; функции, предназначенные для обработки внутренних данных объекта данного класса.
Методы можно разделить на две основные группы — методы экземпляра, которые принадлежат группе функций экземпляра, и статические методы с ключевым словом static, в заголовке метода, которые принадлежат к группе статических функций. Статистические методы принадлежат классу а не объекту. Вызов статических методов и методов экземпляра различен.
Определение метода состоит из заголовка и тела метода. В заголовке указываются важные атрибуты, определяющие, как другие части программы осуществляют доступ к методу. Тело метода состоит из операторов, выполняющихся при его вызове.
Метод представляет собой законченный фрагмент кода, к которому можно обратиться по имени. Он описывается один раз, а вызываться может многократно.
Перегрузка позволяет определять в одном классе несколько различных методов с одним именем, но разными наборами формальных параметров и реализацией. 
Для перегрузки метода достаточно просто присвоить всем трем методам одно имя.
С перегрузкой метода связана важная концепция — сигнатура метода. Имя метода вместе с числовым типом и порядком формальных параметров составляют сигнатуру метода. 
Все методы в классе должны иметь разные сигнатуры. Поскольку имя метода — один из нескольких атрибутов, определяющих сигнатуру метода, в одном классе можно определить несколько методов с одним именем при условии, что остальные элементы сигнатур различаются. Такие методы называются перегруженными.

7. Охарактеризовать и привести примеры рекурсивных методов
Рекурсивным называют метод, если он вызывает сам себя в качестве вспомогательного. В основе рекурсивного метода лежит так называемое "рекурсивное определение" какого-либо понятия. Классическим примером рекурсивного метода является метод, вычисляющий факториал:
{
   static long F(int n) {  //рекурсивный метод 
      if (n==0 || n==1) 
       return 1;    //нерекурсивная ветвь
       else return n*F(n-1);  //шаг рекурсии - повторный вызов метода с другим параметром
    }
    static void Main() {
      Console.Write("n=");
       int n =int.Parse( Console.ReadLine());
       long f=F(n); //нерекурсивный вызов метода F
       Console.WriteLine("{0}!={1}",n, f); 
      }
}
Рекурсивный метод печати элементов символьного массива static void chPrint(char[] ch, int beg):
{
if (beg >= ch.Length-1 || ch[beg] == ’') {
Console.WriteLine(); return;
}
Console.Write(ch[beg] + " ");
chPrint(ch, beg + 1);
}

8. Охарактеризуйте массивы, как объекты в С#.
Массив - набор элементов одного и того же типа, объединенных общим именем. Массивы в С# можно использовать по аналогии с тем, как они используются в других языках программирования. Однако С#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того - реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа. Выделение памяти под элементы происходит на этапе инициализации массива. А за освобождением памяти следит система сборки мусора.
Типы массивов:
•	Одномерные массивы
Одномерный массив — это фиксированное количество элементов одного и того же типа, объединенных общим именем, где каждый элемент имеет свой номер (индекс). Нумерация элементов массива в С# начинается с нуля.
Одномерный массив в С# реализуется как объект, поэтому его создание представляет собой двухступенчатый процесс. Сначала объявляется ссылочная переменная на массив, затем выделяется память под требуемое количество элементов базового типа, и ссылочной переменной присваивается адрес нулевого элемента в массиве. Базовый тип определяет тип данных каждого элемента массива. 
Массив как объект
Массивы реализованы на основе базового класса Array, определенного в пространстве имен System. Данный класс содержит различные свойства и методы.
•	Многомерные массивы
Многомерные массивы имеют более одного измерения (индекса). Чаще всего используются двумерные массивы, которые представляют собой таблицы. Каждый элемент массива имеет два индекса, первый определяет номер строки, второй - номер столбца, на пересечении которых находится элемент. Нумерация строк и столбцов начинается с нуля.

9. Оператор foreach и его использование при работе с массивами.
Оператор foreach применяется для перебора элементов в специальным образом организованной группе данных, в том числе и в массиве. Удобство этого вида цикла заключается в том, что нам не требуется определять количество элементов в группе и выполнять перебор по индексу - мы просто указываем на необходимость перебрать все элементы группы. Синтаксис оператора:
foreach (<тип> <имя> in <группа>) <тело цикла>
где имя определяет локальную по отношению к циклу переменную, которая будет по очереди принимать все значения из указанной группы, а тип соответствует базовому типу элементов группы.
Ограничением оператора foreach является то, что с его помощью можно только просматривать значения элементов в группе данных, но нельзя их изменять.

10. Классы в С#: конструкторы и деструкторы.
Класс – конструкция языка, состоящая из ключевого слова class, идентификатора (имени) и тела; это множество объектов с одинаковыми атрибутами и поведением, представляемое в языке программирования в виде абстрактного типа данных, который включает в себя члены класса:
•	Поля – данные определенного типа для описания атрибутов;
•	Методы - функции, предназначенные для обработки внутренних данных объекта данного класса;
•	Свойства – специальные поля данных, с помощью которых можно управлять поведением объектов данного класса.
Класс служит образцом для создания объектов или, другими словами, объект является экземпляром класса. Класс определяет общие черты группы подобных друг другу объектов. Он является ссылочным типом. 
Класс – это структурированный тип данных, объединяющий переменные и методы, работающие с ними и реализованный на принципах инкапсуляции, наследования и полиморфизма. Программист создает экземпляр класса с помощью операции new.
Класс может содержать следующие функциональные элементы:
1.	Данные: переменные или константы.
2.	Методы,
3.	Конструкторы 
4.	Свойства 
5.	Деструкторы 
6.	Индексаторы 
7.	Операции 
8.	События 
9.	Типы
По умолчанию элементы класса считаются закрытыми private. Для полей класса этот вид доступа является предпочтительным, поскольку поля определяют внутреннее строение класса, которое должно быть скрыто от пользователя. Все методы класса имеют непосредственный доступ к его закрытым полям.
Поля, описанные со спецификатором static, а также константы существуют в единственном экземпляре для всех объектов класса, поэтому к ним обращаются не через имя экземпляра, а через имя класса. 
Конструкторы
Конструктор представляет собой специальный метод, запускающийся по ключевому слову  new. Он используется для инициализации переменных и других операциях при создании объекта.
Конструкторы экземпляра
Конструктор экземпляра вызывается автоматически при создании объекта класса с помощью операции new. Имя конструктора совпадает с именем класса. Основные свойства:
1.	Конструктор не возвращает значение, даже типа void.
2.	Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализации.
3.	Если программист не указал ни одного конструктора или какие-то поля не были инициализированы, полям значимых типов присваивается нуль, полям ссылочных типов - значение null.
Если один из конструкторов выполняет какие-либо действие, а другой должен делать то же самое плюс еще что-нибудь, то удобно вызвать первый конструктор из второго. Для этого используется ключевое слово this.
Конструкторы класса
Статические классы содержат только статические члены, в том числе и конструктор, которые хранятся в памяти в единственном экземпляре. Поэтому создавать экземпляры класса нет смысла.
Деструкторы
Деструктор – метод, занимающийся удалением ненужных объектов из памяти компьютера. В деструкторе описываются действия, гарантирующие корректность последующего удаления объекта. Например, проверяется все ли ресурсы, используемые объектом, освобождены (файлы закрыты, удаленное соединение разорвано и т. п.).
Синтаксис деструктора:
[атрибуты] [extern] ~имя_класса()
{тело_деструктора}
Деструктор не имеет параметров, не возвращает значения и не требует указания спецификаторов доступа. Его имя совпадает с именем класса и предваряется тильдой ( ~ ), символизирующей обратные по отношению к конструктору действия. Тело деструктора представляет собой блок или просто точку с запятой. Если деструктор определен как внешний, то используется спецификатор extern. В общем случае применение деструкторов замедляет процесс сборки мусора. Поэтому создавать деструкторы следует только тогда, когда необходимо освободить какие-то ресурсы перед удалением объекта.

11. Дайте характеристику свойствам класса в С#.
Свойство – это конструкция языка C#, которая заменяет собой использование обычных методов доступа; специальная конструкция имитирующая поле. Свойство состоит из имени, типа и тела. В теле задаются методы доступа, через использование ключевых слов set и get.
Блок set автоматически срабатывает тогда, когда свойству пытаются присвоить значение. Это значение представлено ключевым словом value.
Блок get автоматически срабатывает тогда, когда мы пытаемся получить значение.
Свойства обеспечивают надежную и элегантную поддержку одного из принципов ООП - принципа инкапсуляции.
Они позволяют обращаться к закрытым (private) переменным экземпляра так же, как и к открытым (public), т.е. без громоздких методов называемых аксессорами и мутаторами. 
Применение свойств не приводит к нарушению зашиты и сокрытия данных (что необходимо при использовании переменных экземпляра private), поскольку свойства реализуются внутри класса почти так же, как и методы.
Автоматически реализуемые свойства – это более лаконичная форма свойств, их есть смысл использовать, когда в методах доступа get и set не требуется дополнительная логика. При создании автоматически реализуемых свойств, компилятор создаст закрытое, анонимное резервное поле, которое будет доступно с помощью методов get и set свойства.
Синтаксис свойства:
[атрибуты] [спецификаторы] тип имя_свойства
{
   [get код_доступа]
   [set код_доступа]
}
Значения спецификаторов для свойств и методов аналогичны. Чаще всего свойства объявляются как открытые (со спецификатором public ).

12. Охарактеризуйте индексаторы, приведите примеры для С#.
Индексатор представляет собой разновидность свойства и обычно применяется для организации доступа к скрытым полям класса по индексу, например, так же, как мы обращаемся к элементу массива. Синтаксис индексатора:
[атрибуты] [спецификаторы] тип this [список параметров] /* последние [ ] являются элементами синтаксиса*/
{
 [get код_доступа]
 [set код_доступа]
}
Спецификаторы аналогичны спецификаторам свойств и методов. Индексаторы чаще всего объявляются со спецификатором public, поскольку они входят в интерфейс объекта. Атрибуты и спецификаторы могут отсутствовать.
Индексаторы позволяют индексировать экземпляры класса или структуры также, как массивы. Индексаторы напоминают свойства, но их методы доступа принимают параметры.
Для обращения к отдельному элементу массива применяется индекс в квадратных скобках после имени:...accounts[4]...
Хотя доступ к объекту осуществляется теми же средствами, что и к массиву, индексатор не поддерживает методы и свойства обычного массива. 
public class Matrix {
	public const int n = 10;
	public int[,] elements = new int[n,n];

	public int this[int i, int j]
	{
		get { return elements[i,j]; }
		set { elements[i,j] = value; }
	}
}
Matrix a = new Matrix();
a[0,0] = 1; a[1,5] = 5;
Matrix b = new Matrix();
b[0,0] = -4; b[1,5] = 10;

13. Охарактеризуйте операции класса, приведите примеры для С#.
С# позволяет переопределить большинство операций так, чтобы при использовании их объектами конкретного класса выполнялись действия, отличные от стандартных.
Операции класса описываются с помощью методов специального вида, синтаксис которых выглядит следующим образом:
[ атрибуты] спецификаторы объявитель_операции
{тело}
В качестве спецификаторов одновременно используются ключевые слова public и static. Кроме того, операцию можно объявить как внешнюю - extern.
Унарные операции:
 + - ! ~ ++ --, а также константы true и false. При этом, если была перегружена константа true, то должна быть перегружена и константа false, и наоборот.
Синтаксис: тип operator унарная_операция (параметр)
Параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. При этом операция должна возвращать:
1.	для операций +, -, !, ~ величину любого типа;
2.	для операций ++, -- величину типа класса, для которого она определяется;
3.	для операций true и false величину типа bool.
Бинарные операции:
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
Синтаксис: тип operator бинарная_операция (параметр1, параметр2)
Операции преобразования типа обеспечивают возможность явного и неявного преобразования между пользовательскими типами данных. Синтаксис объявителя операции преобразования типа:
implicit operator тип ( параметр )       // неявное преобразование
explicit operator тип ( параметр )       // явное преобразование

14. Дайте определение свойству ООП наследование. применяется для следующих взаимосвязанных целей:
Наследование  - это отношение между классами, при котором класс использует структуру или поведение другого класса (одиночное наследование), или других (множественное наследование) классов. Наследование вводит иерархию "общее/частное", в которой подкласс наследует от одного или нескольких более общих суперклассов. Подклассы обычно дополняют или переопределяют унаследованную структуру и поведение.
Наследование применяется для следующих взаимосвязанных целей:
1.	исключения из программы повторяющихся фрагментов кода;
2.	упрощения модификации программы;
3.	упрощения создания новых программ на основе существующих.
Наследование является единственной возможностью использовать объекты, исходный код которых недоступен, но в которые требуется внести изменения. Синтаксис наследования:
[атрибуты] [спецификаторы] class имя_класса [: предки]
{ тело_класса}
Класс, который наследуется, называется базовым. Класс, который наследует базовый класс, называется производным. Производный класс, наследует все переменные, методы, свойства, операторы и индексаторы, определенные в базовом классе, кроме того в производный класс могут быть добавлены уникальные элементы или переопределены существующие.

15. Охарактеризуйте наследование конструкторов.
В иерархии классов как базовые, так и производные классы могут иметь собственные конструкторы. При этом конструктор базового класса создает часть объекта, соответствующую базовому классу, а конструктор производного класса - часть объекта, соответствующую производному классу. Так как базовый класс не имеет доступа к элементам производного класса, то их конструкторы должны быть раздельными.
Если конструктор определен только в производном классе, то все происходит очень просто: конструируется объект производного класса, а базовая часть объекта автоматически собирается его конструктором, используемым по умолчанию.
Когда конструкторы определяются как в базовом, так и в производном классе, процесс построения объекта несколько усложняется, поскольку должны выполняться конструкторы обоих классов. В данном случае приходится обращаться к ключевому слову base, которое находит двоякое применение: во-первых, для вызова конструктора базового класса; и во-вторых, для доступа к члену базового класса, скрывающегося за членом производного класса.
С помощью формы расширенного объявления конструктора производного класса и ключевого слова base в производном классе может быть вызван конструктор, определенный в его базовом классе. 

16. Охарактеризуйте интерфейсы в С#.
Главной предпосылкой появления понятие интерфейс является запрет множественного наследования в языке программирования C#. класс С# может наследоваться от другого класса и любого количества интерфейсов. 
Интерфейс  – конструкция в коде программы, используемая для специфицирования услуг, предоставляемых классом или компонентом; это логическая конструкция языка С#, которая представляет собой некоторую спецификацию состоящую только из абстрактных конструкций.
Особенности интерфейсов:
•	Невозможно создать экземпляр интерфейса. 
•	Интерфейсы и члены интерфейсов являются абстрактными по умолчанию и не имеют реализации 
•	Интерфейс содержит только сигнатуры методов, свойств, событий или индексаторов. 
•	Члены интерфейсов автоматически являются открытыми, абстрактными, и они не могут иметь модификаторы доступа. 
•	Интерфейсы не могут содержать константы, поля, операторы, конструкторы экземпляров, деструкторы или типы.
•	Интерфейс может наследоваться от одного или нескольких базовых интерфейсов.
•	Имя интерфейса должно начинаться с I(IInterface )
Синтаксис интерфейса:
[атрибуты] [спецификаторы] interface имя_интерфейса : [предки]
{
//объявление функциональных членов интерфейса без реализации
... 
}
Для интерфейса могут быть указаны спецификаторы new, public, internal и private. Спецификатор new применяется для вложенных интерфейсов и имеет такой же смысл, как и соответствующий спецификатор метода класса. По умолчанию интерфейс доступен только из сборки, в которой он описан (internal).
Все функциональные члены интерфейса по умолчанию являются открытыми (public) и абстрактными ( abstract ), поэтому при описании метода указывается только тип возвращаемого им значения и сигнатуры.
В качестве функциональных членов в интерфейсе можно объявлять сигнатуры методов, свойств, индексаторов и событий. Интерфейсы не могут содержать члены данных, конструкторы, деструкторы или операторные методы (методы, переопределяющие операции). Ни один член интерфейса не может быть объявлен статическим.

17. Охарактеризуйте коллекции общего назначения: стек, очередь, динамический массив, хеш-таблица.
Коллекция  это набор объектов схожих типов, сгруппированных вместе. 
Коллекции общего назначения
Классы коллекций общего назначения:
Класс Stack
АТД стек - это частный случай однонаправленного списка, добавление элементов в который и выборка элементов из которого выполняются с одного конца, называемого вершиной стека (головой - head ). Действует по принципу: последним пришел - первым вышел. При выборке элемент исключается из стека.
Класс Queue
АТД очередь - это частный случай однонаправленного списка, добавление элементов в который выполняется в один конец (хвост), а выборка производится с другого конца (головы). Действует по принципу: первым пришел - первым вышел. При выборке элемент исключается из очереди. 
Класс ArrayList
ArrayList - Динамический массив, т.е. массив который при необходимости может увеличивать свой размер. Объект класса ArrayList представляет собой массив переменной длины, элементами которого являются объектные ссылки. Любой объект класса ArrayList создается с некоторым начальным размером. При превышении этого размера коллекция автоматически удваивается. В случае удаления объектов массив можно сократить. Свойство Capacity позволяет узнать или установить емкость вызывающего динамического массива типа ArrayList.
Класс Hashtable
Класс Hashtable предназначен для создания коллекции, в которой для хранения объектов используется хеш-таблица. В хеш-таблице для хранения информации используется механизм, именуемый хешированием (hashing). Суть хеширования состоит в том, что для определения уникального значения, которое называется хеш-кодом, используется информационное содержимое соответствующего ему ключа. Хеш-код затем используется в качестве индекса, по которому в таблице отыскиваются данные, соответствующие этому ключу. Для добавления элемента в хеш-таблицу необходимо вызвать метод Add(), который принимает два отдельных аргумента: ключ и значение.
SortedList - Отсортированный список пар ключ/значение

18. Дайте определение операциям класса, приведите примеры (бинарные операции).
Бинарные операции
При разработке класса можно перегрузить следующие бинарные операции: + - * / % & | ^ << >> == != < > <= >=. 
Синтаксис объявителя бинарной операции:
тип operator бинарная_операция (параметр1, параметр 2)
Примеры заголовков бинарных операций:
public static DemoArray operator + (DemoArray a, DemoArray b)
public static bool operator == (DemoArray a, DemoArray b)
При переопределении бинарных операций нужно учитывать следующие правила:
1.	Хотя бы один параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется.
2.	Операция может возвращать величину любого типа.
3.	Операции отношений определяются только парами и обычно возвращают логическое значение. Чаще всего переопределяются операции сравнения на равенство и неравенство для того, чтобы обеспечить сравнение значения некоторых полей объектов, а не ссылок на объект. Для того чтобы переопределить операции отношений, требуется знание стандартных интерфейсов, которые будут рассматриваться чуть позже.

19. Дайте определение операциям класса, приведите примеры (операции преобразования типов).
Операции преобразования типов
Операции преобразования типов обеспечивают возможность явного и неявного преобразования между пользовательскими типами данных. Синтаксис объявителя операции преобразования типов выглядит следующим образом:
explicit operator целевой_тип (параметр)  //явное преобразование
implicit operator целевой_тип (параметр)  //неявное преобразование
Эти операции выполняют преобразование из типа параметра в тип, указанный в заголовке операции. Одним из этих типов должен быть класс, для которого выполняется преобразование.
Неявное преобразование выполняется автоматически в следующих ситуациях:
1.	при присваивании объекта переменной целевого типа;
2.	при использовании объекта в выражении, содержащем переменные целевого типа;
3.	при передаче объекта в метод параметра целевого типа;
4.	при явном приведении типа.
Явное преобразование выполняется при использовании операции приведения типа.
При определении операции преобразования типа следует учитывать следующие особенности:
1.	тип возвращаемого значения (целевой_тип) включается в сигнатуру объявителя операции;
2.	ключевые слова explicit и implicit не включаются в сигнатуру объявителя операции.
Следовательно, для одного и того класса нельзя определить одновременно и явную, и неявную версию. Однако, т.к. неявное преобразование автоматически выполнятся при явном использовании операции приведения типа, то достаточно разработать только неявную версию операции преобразования типа.

20.  В каких случаях используется служебное слово base.
Если же конструкторы определены и в базовом, и в производном классе, то процесс создания объектов несколько усложняется, т.к. должны выполниться конструкторы обоих классов. В этом случае используется ключевое слово base, которое имеет два назначения:
1. позволяет вызвать конструктор базового класса:
Производный класс может вызывать конструктор, определенный в его базовом классе, используя расширенную форму объявления конструктора и ключевое слово base. Формат расширенного объявления:
конструктор_производного_класса (список_параметров) : base (список_аргументов)
{ тело конструктора }
2. позволяет получить доступ к члену базового класса, который скрыт "за" членом производного класса.
В этом случае ключевое слово base действует подобно ссылке this, за исключением того, что ссылка base всегда указывает на базовый класс для производного класса, в котором она используется. В этом случае формат ее записи выглядит следующим образом:
base.член_класса
Здесь в качестве элемента член_класса можно указывать либо метод, либо поле экземпляра. Эта форма ссылки base наиболее применима в тех случаях, когда имя члена в производном классе скрывает член с таким же именем в базовом классе.





