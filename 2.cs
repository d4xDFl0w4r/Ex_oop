1. В С# для обмена предусмотрено четыре типа параметров: параметры-значения, параметры-ссылки, выходные параметры, параметры-массивы. Сравните их.
1.При передаче параметров по ссылке перед параметрами используется модификатор ref. При изменении переменной в методе, изменяется и исходная переменная, ссылка на которую была передана. Кушает меньше памяти, чем значение
void Increment(ref int n)
2.Модификатор in указывает, что параметр будет передаваться в метод по ссылке, однако внутри метода его значение параметра нельзя будет изменить. (ref c защитой от дурака. Да ещё и дешевле, чем значение)
void Increment(in int n)
3.Чтобы сделать параметр выходным, перед ним ставится модификатор out. По сути, удобный способ иметь более одного retutn’а. ри Eсли нам неизвестен тип значений, которые будут присвоены параметрам, то мы можем для их определения использовать оператор var:
void Sum(int x, int y, out int result, out var strangeResult)
{
    result = x + y;
}
Sum(10, 15, out number);
int number;
4.При вызове метода на место параметра с модификатором params мы можем передать как отдельные значения, так и массив значений, либо вообще не передавать параметры. Количество передаваемых значений в метод неопределено, однако все эти значения должны соответствовать типу параметра с params. Параметр-массив обязательно последний параметр.
void Sum(params int[]  numbers) {}
int[] nums = { 1, 2, 3, 4, 5};
Sum(nums);  // число 10 - передается параметру initialValue
Sum(1, 2, 3, 4);
Sum(1, 2, 3);
Sum(20);

2.  Охарактеризуйте механизм генерации исключительных ситуаций в С#.
Генерировать исключения вручную можно с помощью оператора throw. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.
После оператора throw указывается объект исключения, через конструктор которого мы можем передать сообщение об ошибке. Объект исключения – обязательной экземпляр класса, наследного от System.Exception или его самого.
throw new Exception("За что мне всё это…");
Подобным образом мы можем генерировать исключения в любом месте программы. Но существует также и другая форма использования оператора throw, когда после данного оператора не указывается объект исключения. В подобном виде оператор throw может использоваться только в блоке catch для передачи исключения выше по стеку.

3. Сравните неизменяемые строки string и изменяемые строки StringBuilder. Ответ проиллюстрируйте примерами.
Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места. Удаление первого символа - не самая затратная операция. Однако когда подобных операций множество, а объем текста, для которого надо выполнить данные операции, также не самый маленький, то издержки при потере производительности становятся более существенными.
Microsoft рекомендует использовать класс String в следующих случаях:
•	При небольшом количестве операций и изменений над строками
•	При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну
•	Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StringBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:
•	При неизвестном количестве операций и изменений над строками во время выполнения программы
•	Когда предполагается, что приложению придется сделать множество подобных операций
Неизменяемые строки string
Тип string, предназначенный для работы со строками символов в кодировке Unicode, является встроенным типом С#. Ему соответствует базовый тип класса System.String библиотеки .Net. Каждый объект string - это неизменяемая последовательность символов Unicode, т.е. методы, предназначенные для изменения строк, возвращают измененные копии, исходные же строки остаются неизменными.
Изменяемые строки
Чтобы создать строку, которую можно изменять, в С# предусмотрен класс StringBuilder, определенный в пространстве имен System.Text. Объекты этого класса всегда объявляются с явным вызовом конструктора класса (через операцию new ) . Примеры создания изменяемых строк:
StringBuilder a =new StringBuilder();	//создание пустой строки, размер по умолчанию 16 символов
//инициализация строки и выделение необходимой памяти
StringBuilder b = new StringBuilder("abcd"); 
//создание пустой строки и выделение памяти под 100 символов
StringBuilder с = new StringBuilder(100);
//инициализация строки и выделение памяти под 100 символов 
StringBuilder d = new StringBuilder("abcd", 100);
//инициализация подстрокой "bcd", и выделение памяти под 100 символов	
StringBuilder d = new StringBuilder("abcd", 1, 3,100);
Методы класса StringBuilder менее развиты, чем методы класса String, но они позволяют более эффективно использовать память за счет работы с изменяемыми строками.

4. Проведите анализ задач с регулярными выражениями.
Поиск фрагментов строки, соответствующих заданному выражению, выполняется с помощью методов IsMatch, Match, Matches класса Regex. 
Метод IsMatch возвращает true, если фрагмент, соответствующий выражению, в заданной строке найден, и false в противном случае.
Regex r = new Regex("text",RegexOptions.IgnoreCase);
Console.WriteLine(r.IsMatch(“text”));
Метод Match класса Regex не просто определяет, содержится ли текст, соответствующий шаблону, а возвращает объект класса Match - последовательность фрагментов текста, совпавших с шаблоном.
MatchCollection theMatches = theReg.Matches(text);
Метод Matches класса Regex возвращает объект класса MatchCollection - коллекцию всех фрагментов заданной строки, совпавших с шаблоном. При этом метод Matches многократно запускает метод Match, каждый раз начиная поиск с того места, на котором закончился предыдущий поиск.

Метод Replace класса Regex позволяет выполнять замену одного фрагмента текста другим или удаление фрагментов текста:
string newText=Regex.Replace(text, @"\d{2,3}(-\d\d){2}", "");
Регулярные выражения представляют эффективный и гибкий метод по обработке больших текстов, позволяя в то же время существенно уменьшить объемы кода по сравнению с использованием стандартных операций со строками. Регулярные выражения позволяют осуществлять поиск по шаблону в тексте.
 центральным классом при работе с регулярными выражениями является класс Regex. Например, у нас есть некоторый текст и нам надо найти в нем все словоформы какого-нибудь слова. 
Регулярное выражение используется для проверки соответствия строки шаблону.
// Создаем шаблон для слова, которое начинается с буквы "M"  
string p = @"\b[M]\w+";  
// Создаем экземпляр Regex  
Regex r = new Regex(p);  

// Длинная строка  
string vech= "Machina, Myach";  
// Получаем все совпадения  
MatchCollection matchedVech = r.Matches(vech);  
/// Выводим всех подходящих авторов  
for (int count = 0; count < matchedVech.Count; count++)  
Console.WriteLine(matchedAuthors[count].Value);  
В приведенном выше примере код ищет символ «M». Но что, если слово начинается с «м».

5. Как в С# организованы системы ввода-вывода в консольном режиме?
Для вывода информации на консоль мы уже использовали встроенный метод Console.WriteLine. То есть, если мы хотим вывести некоторую информацию на консоль, то нам надо передать ее в метод Console.WriteLine:
string hello = "Привет мир";
Console.WriteLine(hello);
Console.WriteLine("Добро пожаловать в C#!");
Console.WriteLine("Пока мир...");
Console.WriteLine(24.5);
Нередко возникает необходимость вывести на консоль в одной строке значения сразу нескольких переменных. В этом случае мы можем использовать прием, который называется интерполяцией:
string name = "Tom";
int age = 34;
double height = 1.7;
Console.WriteLine($"Имя: {name}  Возраст: {age}  Рост: {height}м");
Для встраивания отдельных значений в выводимую на консоль строку используются фигурные скобки, в которые заключается встраиваемое значение. Это можем значение переменной ({name}) или более сложное выражение (например, операция сложения {4 + 7}). А перед всей строкой ставится знак доллара $.
Кроме Console.WriteLine() можно также использовать метод Console.Write(), он работает точно так же за тем исключением, что не добавляет переход на следующую строку, то есть последующий консольный вывод будет выводиться на той же строке.
мы можем получать информацию с консоли. Для этого предназначен метод Console.ReadLine(). Он позволяет получить введенную строку.
1
2
3	Console.Write("Введите свое имя: ");
string? name = Console.ReadLine();
Console.WriteLine($"Привет {name}");
Особенностью метода Console.ReadLine() является то, что он может считать информацию с консоли только в виде строки. 

6.  Сформулируйте принципы наследования в С#.
•	Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:
•	Не поддерживается множественное наследование, класс может наследоваться только от одного класса.
•	При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, но не public.
•	Однако следует также учитывать, что если базовый и производный класс находятся в разных сборках (проектах), то в этом случае производый класс может наследовать только от класса, который имеет модификатор public.
•	Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы.
•	Нельзя унаследовать класс от статического класса.
•	производный класс может иметь доступ только к тем членам базового класса, которые определены с модификаторами private и protected
•	С помощью ключевого слова base мы можем обратиться к конструктору базового класса в конструкторе производного.

7. Для чего используют виртуальные методы в С#.
Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.
А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override. Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
При переопределении виртуальных методов следует учитывать ряд ограничений:
•	Виртуальный и переопределенный методы должны иметь один и тот же модификатор доступа. То есть если виртуальный метод определен с помощью модификатора public, то и переопредленный метод также должен иметь модификатор public.
•	Нельзя переопределить или объявить виртуальным статический метод.

8.  Для чего используют абстрактные методы и классы в С#.
Абстрактный класс  объявляется с ключевым словом abstract. 
 В абстрактном классе обычно реализуется некоторая общая абстрактная сущность, которая, как объект, не может существовать, но эта часть необходима в классах-наследниках.
Абстрактный метод – это метод, который не имеет своей реализации в базовом классе, но он должен быть реализован в классе-наследнике. Абстрактный метод может быть объявлен только в абстрактном классе.
Назначение абстрактного класса заключается в предоставлении общего определения для базового класса, которое могут совместно использовать несколько производных классов.
Абстрактный класс похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. Единственное, что при определении абстрактных классов используется ключевое слово abstract. Главное отличие абстрактных классов от обычных состоит в том, что мы НЕ можем использовать конструктор абстрактного класса для создания экземпляра класса. Тем не менее абстрактные классы полезны для описания некоторого общего функционала, который могут наследовать и использовать производные классы:
1.	abstract class Transport
2.	{
3.	    public void Move()
4.	    {
5.	        Console.WriteLine("Транспортное средство движется");
6.	    }
7.	}
8.	// класс корабля
9.	class Ship : Transport { }
10.	// класс самолета
11.	class Aircraft : Transport { }
12.	// класс машины
13.	class Car : Transport { }
Абстрактные члены классов не должны иметь модификатор private. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором override (как и при обычном переопределении виртуальных методов и свойств). Также следует учесть, что если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как абстрактный.
Производный класс обязан реализовать все абстрактные члены базового класса. Однако мы можем отказаться от реализации, но в этом случае производный класс также должен быть определен как абстрактный:

9. Как организовать запрет наследования в С#.
В С# есть ключевое слово sealed, позволяющее описать класс, от которого запрещено наследование. Например:
sealed class Demo {   … }
class newDemo: Demo {   …  }  // ошибка
1.	sealed class NoInheritance
2.	 *Surprised Pikachu*

10. Охарактеризуйте особенности структур в С#.
Структура (struct) в C# — это пользовательский тип данных, который используется наряду с классами и может содержать какие-либо данные и методы. Структурами также являются такие типы данных как int, double и т.д. Основное отличие структуры (struct) от класса (class) заключается в том, что структура — это тип значений, а класс — это ссылочный тип.
struct имя_структуры
{
   // элементы структуры
}
Для использования структуры ее необходмо инициализировать. Для инициализации создания объектов структуры, как и в случае с классами, применяется вызов конструктора с оператором new. 
Даже если в коде структуры не определено ни одного конструктора, тем не менее имеет как минимум один конструктор - конструктор по умолчанию, который генерируется компилятором. Этот конструктор не принимает параметров и создает объект структуры со значениями по умолчанию.
Если при объявлении структуры не был вызван конструктор, то поля нужно инициализировать вручную
Eсли в структуре определяется конструктор, то в нем обязательно надо инициализировать все поля структуры.

11. Проклассифицируйте коллекции. Приведите пример.
Классы в пространстве имен System.Collections хранят элементы не в виде конкретно типизированных объектов, а как объекты типа Object.
Везде, где это возможно, следует использовать универсальные коллекции пространства имен System.Collections.Generic или пространства имен System.Collections.Concurrent вместо устаревших типов пространства имен System.Collections.
В следующей таблице перечислены некоторые из часто используемых классов пространства имен System.Collections:
Класс	Описание
ArrayList
Представляет массив объектов, размер которого динамически увеличивается по мере необходимости.
Hashtable
Представляет коллекцию пар «ключ-значение», которые упорядочены по хэш-коду ключа.
Queue
Представляет коллекцию объектов, которая обслуживается в порядке поступления (FIFO).
Stack
Представляет коллекцию объектов, которая обслуживается в обратном порядке (LIFO).
Классы System.Collections.Generic
Универсальную коллекцию можно создать, используя один из классов в пространстве имен System.Collections.Generic. Универсальная коллекция применяется в том случае, если все элементы в коллекции имеют одинаковый тип данных. Универсальная коллекция обеспечивает строгую типизацию, позволяя добавлять данные только необходимого типа.
В таблице ниже перечислены некоторые из часто используемых классов пространства имен System.Collections.Generic.
Класс	Описание
Dictionary<TKey,TValue>
Предоставляет коллекцию пар «ключ-значение», 
которые упорядочены по ключу.
List<T>
Представляет список объектов, доступных по индексу. Предоставляет методы для поиска по списку, его сортировки и изменения.
Queue<T>
Представляет коллекцию объектов, которая обслуживается в порядке поступления (FIFO).
SortedList<TKey,TValue>
Представляет коллекцию пар "ключ-значение", упорядоченных по ключу на основе реализации.
Stack<T>
Представляет коллекцию объектов, которая обслуживается в обратном порядке (LIFO).
Пространство имен System.Collections.Specialized предоставляет специализированные и строго типизированные классы коллекций, такие как коллекции строк, связанные списки и гибридные словари.

12. Чем отличается С# от С++?
С# (произносится как "си шарп") — это современный язык программирования, в котором, по замыслу создателей, должны сочетаться выразительность и простота. 
Его цель  — позволить программисту создавать сложные высокопроизводительные программы.
Отличия:
•	C++ компилируется со специальными программами компиляции в машинный код, а C# превращается в собственный код с помощью среды CLR. 
•	В C# управление памятью намного проще, чем в C++. C# предлагает автоматическую сборку мусора, которая управляет выделением памяти. Сборка мусора в C# означает, что C# автоматически освобождает дополнительное пространство из неиспользуемых объектов. C++ не предлагает такой возможности.
•	C++ допускает множественное наследование, а C# — нет. Концепция множественного наследования означает, что класс может наследовать от нескольких классов. При сравнении скорости C# и C++, второй выигрывает. Следовательно, для программ, требующих высокой производительности, лучше выбирать C++. Однако есть способы оптимизации кода C#, чтобы сделать его скорость похожей на C ++. 
•	Несмотря на то, что C# работает во всех популярных ОС, он является наиболее популярным в среде Windows. C ++ не имеет предпочтительной или более популярной ОС. 

13. Сравните чем отличается реализация массивов в С++ и С#?
Массивы в С# можно использовать по аналогии с тем, как они используются в C++. Однако С#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того - реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа. Выделение памяти под элементы происходит на этапе инициализации массива. А за освобождением памяти следит система сборки мусора - неиспользуемые массивы автоматически утилизируются данной системой.
Одномерный массив в С# реализуется как объект, поэтому его создание представляет собой двухступенчатый процесс. Сначала объявляется ссылочная переменная на массив, затем выделяется память под требуемое количество элементов базового типа, и ссылочной переменной присваивается адрес нулевого элемента в массиве. Базовый тип определяет тип данных каждого элемента массива. Количество элементов, которые будут храниться в массиве, определяется размер массива.

14. Можно ли при работе с многомерными массивами использовать приемы, которые используются для одномерных массивов в С#. Приведите примеры.
Многомерные массивы имеют более одного измерения (индекса). Чаще всего используются двумерные массивы, которые представляют собой таблицы. Каждый элемент массива имеет два индекса, первый определяет номер строки, второй - номер столбца, на пересечении которых находится элемент. Нумерация строк и столбцов начинается с нуля.
При работе с многомерными массивами можно использовать приемы, которые используются одномерных массивов.
Пример:
class Program
  {
    static void PrintArray(string a, int[,] mas)
    {
      Console.WriteLine(a);
      for (int i = 0; i < mas.GetLength(0); i++)
      {
        for (int j = 0; j < mas.GetLength(1); j++)
          Console.Write("{0} ", mas[i, j]);
        Console.WriteLine();
      }
    }
    static void Change(int[,] mas)
    {
      for (int i = 0; i < mas.GetLength(0); i++)
        for (int j = 0; j < mas.GetLength(1); j++)
          if (mas[i, j] % 2 == 0) mas[i, j] = 0;              
    }

    static void Main()
    {
      try
      {
        int[,] MyArray ={ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        PrintArray("исходный массив:", MyArray);
        Change(MyArray);
        PrintArray("итоговый массив", MyArray);
      }
      catch (FormatException)
      {
            Console.WriteLine("неверный формат ввода данных");
      }
      catch (OverflowException)
      {
            Console.WriteLine("переполнение");
      }
      catch (OutOfMemoryException)
      {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
      }
    }
  }
Объявление ступенчатого массива:
тип [][] имя_массива;
Например:
int [][]a;
Фактически мы объявили одномерный массив ссылок на целочисленные одномерные массивы. При таком описании потребуется не только выделять память под одномерный массив ссылок, но и под каждый из целочисленных одномерных массивов. Такое распределение памяти позволяет определять произвольную длину каждой строки массива (отсюда и произошло название массива - ступенчатый). Например:
int [][] a= new int [3][];  // Создаем три строки
a[0]=new int [2];  // 0-ая строка ссылается на 2-х элементый одномерный массив 
a[1]=new int [3];  // 1-ая строка ссылается на 3-х элементый одномерный массив
a[2]=new int [10];  // 2-ая строка ссылается на 10-ти элементый одномерный массив
Другой способ выделения памяти:
int [][] a= {new int [2], new int [3], new int [10]};
Так как каждая строка ступенчатого массива фактически является одномерным массивом, то с каждой строкой можно работать как с экземпляром класса Array. Это является преимуществом ступенчатых массивов перед двумерными массивами.

15. Дайте характеристику статическим классам.
Статические классы содержат статические объекты, которые нельзя использовать несколько раз. Обычно статические классы используются для размещения статических методов, которые предоставляют вычисления, общие шаблоны обработки, форматы вывода строк и т. д. Статические классы имеют малый вес и не нуждаются в конкретизации.

16. Охарактеризуйте генерацию собственных исключений. Приведите пример.
Для обработки исключений в C# используется специальная конструкция — блок try... catch... finally.
Если возникает проблема внутри программы то в блоке try(попытка) попытается решить возникшую проблему, если проблема решается то дальше блок catch не попадает, если проблема не решается в блоке try то переходит в блок catch и обрабатывает ошибку(решение проблемы или сообщение об ошибке. В блок finally попадает в любом случае, вне зависимости смог ли try решить проблему.  
Есть ещё исключение throw, которое мы создаем в ручную и вызываем в процессе выполнения.  Threw new Exception()
Пример:
Try
{
String name =Console.ReaadLine();
If(name==null)
{
Throw new Exception(“ERROR!”);
}
Else
{
Console.WriteLine(“your name:{name}”);
}
}
Catch(Exception e)
{
Console.WriteLine(e.Message);
}

17. Охарактеризуйте особенности многоуровневой иерархии в С#.
Простой тип иерархии состоит из 1 базового и 1 производного класса. Но можно построить иерархию состоящую из любого количества уровней.
При этом в c# не допускается наследование из 2 и более базовых классов. То есть несколько производных класса могут наследоваться от 1 базового класса. При этом производный класс в своё время может являться базовым классом для других производный классов. 
Например:

Class mlekopit
{
	//методы, поля, конструкторы и т.д
}
Class people : mlekopit
{
	//…
}
Class animal : mlekopit
{
	//…
}
Class domashnie : animal
{
	//…
}
Class dikie : animal
{
	//…	
} 

18. Сравните виртуальные и не виртуальные методы.
Виртуальный метод – это метод, который может быть переопределен в классе наследнике, т.е. можно изменить его реализацию в классе наследнике. Переопределив метод, он будет работать по-разному в базовом классе и классе наследнике, имея при этом одно и то же имя и аргументы и тип возврата. Виртуальный метод создается с помощью ключевого слова virtual и переопределяется с помощью ключевого слова override.  
Тогда как не виртуальный метод нельзя переопределять в классах наследниках, и можно использовать реализовать только 1 раз.

